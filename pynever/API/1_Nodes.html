

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nodes &mdash; pyNeVer 1.1.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=00f267c6"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Training" href="2_Training.html" />
    <link rel="prev" title="Networks" href="0_Networks.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            pyNeVer
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Setup/setup.html">Installation and Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Guide/usage.html">Verification</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0_Networks.html">Networks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Nodes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.LayerNode"><code class="docutils literal notranslate"><span class="pre">LayerNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.LayerNode.identifier"><code class="docutils literal notranslate"><span class="pre">LayerNode.identifier</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.ConcreteLayerNode"><code class="docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConcreteLayerNode.identifier"><code class="docutils literal notranslate"><span class="pre">ConcreteLayerNode.identifier</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConcreteLayerNode.in_dims"><code class="docutils literal notranslate"><span class="pre">ConcreteLayerNode.in_dims</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConcreteLayerNode.out_dim"><code class="docutils literal notranslate"><span class="pre">ConcreteLayerNode.out_dim</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConcreteLayerNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">ConcreteLayerNode.get_input_dim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConcreteLayerNode.get_output_dim"><code class="docutils literal notranslate"><span class="pre">ConcreteLayerNode.get_output_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.ReLUNode"><code class="docutils literal notranslate"><span class="pre">ReLUNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ReLUNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">ReLUNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.ELUNode"><code class="docutils literal notranslate"><span class="pre">ELUNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ELUNode.alpha"><code class="docutils literal notranslate"><span class="pre">ELUNode.alpha</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ELUNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">ELUNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.CELUNode"><code class="docutils literal notranslate"><span class="pre">CELUNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.CELUNode.alpha"><code class="docutils literal notranslate"><span class="pre">CELUNode.alpha</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.CELUNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">CELUNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.LeakyReLUNode"><code class="docutils literal notranslate"><span class="pre">LeakyReLUNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.LeakyReLUNode.negative_slope"><code class="docutils literal notranslate"><span class="pre">LeakyReLUNode.negative_slope</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.LeakyReLUNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">LeakyReLUNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.SigmoidNode"><code class="docutils literal notranslate"><span class="pre">SigmoidNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.SigmoidNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">SigmoidNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.TanhNode"><code class="docutils literal notranslate"><span class="pre">TanhNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.TanhNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">TanhNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.FullyConnectedNode"><code class="docutils literal notranslate"><span class="pre">FullyConnectedNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.FullyConnectedNode.in_features"><code class="docutils literal notranslate"><span class="pre">FullyConnectedNode.in_features</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.FullyConnectedNode.out_features"><code class="docutils literal notranslate"><span class="pre">FullyConnectedNode.out_features</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.FullyConnectedNode.weight"><code class="docutils literal notranslate"><span class="pre">FullyConnectedNode.weight</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.FullyConnectedNode.bias"><code class="docutils literal notranslate"><span class="pre">FullyConnectedNode.bias</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.FullyConnectedNode.has_bias"><code class="docutils literal notranslate"><span class="pre">FullyConnectedNode.has_bias</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.FullyConnectedNode.get_layer_bias_as_two_dimensional"><code class="docutils literal notranslate"><span class="pre">FullyConnectedNode.get_layer_bias_as_two_dimensional()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.FullyConnectedNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">FullyConnectedNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.BatchNormNode"><code class="docutils literal notranslate"><span class="pre">BatchNormNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.num_features"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.num_features</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.weight"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.weight</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.bias"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.bias</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.running_mean"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.running_mean</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.running_var"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.running_var</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.eps"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.eps</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.momentum"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.momentum</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.affine"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.affine</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.track_running_stats"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.track_running_stats</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.BatchNormNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">BatchNormNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.ConvNode"><code class="docutils literal notranslate"><span class="pre">ConvNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.in_channels"><code class="docutils literal notranslate"><span class="pre">ConvNode.in_channels</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.out_channels"><code class="docutils literal notranslate"><span class="pre">ConvNode.out_channels</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.kernel_size"><code class="docutils literal notranslate"><span class="pre">ConvNode.kernel_size</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.stride"><code class="docutils literal notranslate"><span class="pre">ConvNode.stride</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.padding"><code class="docutils literal notranslate"><span class="pre">ConvNode.padding</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.dilation"><code class="docutils literal notranslate"><span class="pre">ConvNode.dilation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.groups"><code class="docutils literal notranslate"><span class="pre">ConvNode.groups</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.has_bias"><code class="docutils literal notranslate"><span class="pre">ConvNode.has_bias</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.bias"><code class="docutils literal notranslate"><span class="pre">ConvNode.bias</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.weight"><code class="docutils literal notranslate"><span class="pre">ConvNode.weight</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConvNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">ConvNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.AveragePoolNode"><code class="docutils literal notranslate"><span class="pre">AveragePoolNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.AveragePoolNode.kernel_size"><code class="docutils literal notranslate"><span class="pre">AveragePoolNode.kernel_size</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.AveragePoolNode.stride"><code class="docutils literal notranslate"><span class="pre">AveragePoolNode.stride</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.AveragePoolNode.padding"><code class="docutils literal notranslate"><span class="pre">AveragePoolNode.padding</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.AveragePoolNode.ceil_mode"><code class="docutils literal notranslate"><span class="pre">AveragePoolNode.ceil_mode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.AveragePoolNode.count_include_pad"><code class="docutils literal notranslate"><span class="pre">AveragePoolNode.count_include_pad</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.AveragePoolNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">AveragePoolNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.MaxPoolNode"><code class="docutils literal notranslate"><span class="pre">MaxPoolNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.MaxPoolNode.kernel_size"><code class="docutils literal notranslate"><span class="pre">MaxPoolNode.kernel_size</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.MaxPoolNode.stride"><code class="docutils literal notranslate"><span class="pre">MaxPoolNode.stride</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.MaxPoolNode.padding"><code class="docutils literal notranslate"><span class="pre">MaxPoolNode.padding</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.MaxPoolNode.dilation"><code class="docutils literal notranslate"><span class="pre">MaxPoolNode.dilation</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.MaxPoolNode.ceil_mode"><code class="docutils literal notranslate"><span class="pre">MaxPoolNode.ceil_mode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.MaxPoolNode.return_indices"><code class="docutils literal notranslate"><span class="pre">MaxPoolNode.return_indices</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.MaxPoolNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">MaxPoolNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.LRNNode"><code class="docutils literal notranslate"><span class="pre">LRNNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.LRNNode.size"><code class="docutils literal notranslate"><span class="pre">LRNNode.size</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.LRNNode.alpha"><code class="docutils literal notranslate"><span class="pre">LRNNode.alpha</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.LRNNode.beta"><code class="docutils literal notranslate"><span class="pre">LRNNode.beta</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.LRNNode.k"><code class="docutils literal notranslate"><span class="pre">LRNNode.k</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.LRNNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">LRNNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.SoftMaxNode"><code class="docutils literal notranslate"><span class="pre">SoftMaxNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.SoftMaxNode.axis"><code class="docutils literal notranslate"><span class="pre">SoftMaxNode.axis</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.SoftMaxNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">SoftMaxNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.UnsqueezeNode"><code class="docutils literal notranslate"><span class="pre">UnsqueezeNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.UnsqueezeNode.axes"><code class="docutils literal notranslate"><span class="pre">UnsqueezeNode.axes</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.UnsqueezeNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">UnsqueezeNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.ReshapeNode"><code class="docutils literal notranslate"><span class="pre">ReshapeNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ReshapeNode.shape"><code class="docutils literal notranslate"><span class="pre">ReshapeNode.shape</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ReshapeNode.allow_zero"><code class="docutils literal notranslate"><span class="pre">ReshapeNode.allow_zero</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ReshapeNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">ReshapeNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.FlattenNode"><code class="docutils literal notranslate"><span class="pre">FlattenNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.FlattenNode.axis"><code class="docutils literal notranslate"><span class="pre">FlattenNode.axis</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.FlattenNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">FlattenNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.DropoutNode"><code class="docutils literal notranslate"><span class="pre">DropoutNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.DropoutNode.p"><code class="docutils literal notranslate"><span class="pre">DropoutNode.p</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.DropoutNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">DropoutNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.TransposeNode"><code class="docutils literal notranslate"><span class="pre">TransposeNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.TransposeNode.perm"><code class="docutils literal notranslate"><span class="pre">TransposeNode.perm</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.TransposeNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">TransposeNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.ConcatNode"><code class="docutils literal notranslate"><span class="pre">ConcatNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConcatNode.axis"><code class="docutils literal notranslate"><span class="pre">ConcatNode.axis</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.ConcatNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">ConcatNode.get_input_dim()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pynever.nodes.SumNode"><code class="docutils literal notranslate"><span class="pre">SumNode</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pynever.nodes.SumNode.get_input_dim"><code class="docutils literal notranslate"><span class="pre">SumNode.get_input_dim()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="2_Training.html">Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_Conversion.html">Conversion</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pyNeVer</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Nodes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/API/1_Nodes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pynever.nodes">
<span id="nodes"></span><h1>Nodes<a class="headerlink" href="#module-pynever.nodes" title="Link to this heading"></a></h1>
<p>This module contains the classes to define and create neural network layers.
The abstract class <code class="docutils literal notranslate"><span class="pre">LayerNode</span></code> represents a generic NN layer, and its child <code class="docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code> defines
the internal representation of all currently supported layers.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.LayerNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">LayerNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#LayerNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.LayerNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>An abstract class used for our internal representation of a generic Layer.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.LayerNode.identifier">
<span class="sig-name descname"><span class="pre">identifier</span></span><a class="headerlink" href="#pynever.nodes.LayerNode.identifier" title="Link to this definition"></a></dt>
<dd><p>Identifier of the <a class="reference internal" href="#pynever.nodes.LayerNode" title="pynever.nodes.LayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerNode</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.ConcreteLayerNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">ConcreteLayerNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ConcreteLayerNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ConcreteLayerNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.LayerNode" title="pynever.nodes.LayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayerNode</span></code></a></p>
<p>An abstract class used for our internal representation of a generic Layer.
Its concrete children correspond to real network layers.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConcreteLayerNode.identifier">
<span class="sig-name descname"><span class="pre">identifier</span></span><a class="headerlink" href="#pynever.nodes.ConcreteLayerNode.identifier" title="Link to this definition"></a></dt>
<dd><p>Identifier of the <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConcreteLayerNode.in_dims">
<span class="sig-name descname"><span class="pre">in_dims</span></span><a class="headerlink" href="#pynever.nodes.ConcreteLayerNode.in_dims" title="Link to this definition"></a></dt>
<dd><p>Dimension of the input Tensor as a list of tuples (ndarray.shape like).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[tuple]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConcreteLayerNode.out_dim">
<span class="sig-name descname"><span class="pre">out_dim</span></span><a class="headerlink" href="#pynever.nodes.ConcreteLayerNode.out_dim" title="Link to this definition"></a></dt>
<dd><p>Dimension of the output Tensor as a tuple (ndarray.shape like).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.ConcreteLayerNode.get_input_dim">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ConcreteLayerNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ConcreteLayerNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.ConcreteLayerNode.get_output_dim">
<span class="sig-name descname"><span class="pre">get_output_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ConcreteLayerNode.get_output_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ConcreteLayerNode.get_output_dim" title="Link to this definition"></a></dt>
<dd><p>Procedure to get the output dimension of the layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The output dimensions of the layer.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.ReLUNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">ReLUNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ReLUNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ReLUNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a ReLU Layer.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.ReLUNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ReLUNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ReLUNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.ELUNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">ELUNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ELUNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ELUNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of an ELU Layer.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ELUNode.alpha">
<span class="sig-name descname"><span class="pre">alpha</span></span><a class="headerlink" href="#pynever.nodes.ELUNode.alpha" title="Link to this definition"></a></dt>
<dd><p>The alpha value for the ELU formulation (default: 1.0).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.ELUNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ELUNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ELUNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.CELUNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">CELUNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#CELUNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.CELUNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a CELU Layer.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.CELUNode.alpha">
<span class="sig-name descname"><span class="pre">alpha</span></span><a class="headerlink" href="#pynever.nodes.CELUNode.alpha" title="Link to this definition"></a></dt>
<dd><p>The alpha value for the CELU formulation (default: 1.0).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.CELUNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#CELUNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.CELUNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.LeakyReLUNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">LeakyReLUNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negative_slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#LeakyReLUNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.LeakyReLUNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Leaky ReLU Layer.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.LeakyReLUNode.negative_slope">
<span class="sig-name descname"><span class="pre">negative_slope</span></span><a class="headerlink" href="#pynever.nodes.LeakyReLUNode.negative_slope" title="Link to this definition"></a></dt>
<dd><p>Controls the angle of the negative slope (default: 1e-2).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.LeakyReLUNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#LeakyReLUNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.LeakyReLUNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.SigmoidNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">SigmoidNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#SigmoidNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.SigmoidNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Sigmoid Layer.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.SigmoidNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#SigmoidNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.SigmoidNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.TanhNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">TanhNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#TanhNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.TanhNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Tanh Layer.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.TanhNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#TanhNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.TanhNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.FullyConnectedNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">FullyConnectedNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">has_bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#FullyConnectedNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.FullyConnectedNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Fully Connected layer</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.FullyConnectedNode.in_features">
<span class="sig-name descname"><span class="pre">in_features</span></span><a class="headerlink" href="#pynever.nodes.FullyConnectedNode.in_features" title="Link to this definition"></a></dt>
<dd><p>Number of input features of the fully connected layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.FullyConnectedNode.out_features">
<span class="sig-name descname"><span class="pre">out_features</span></span><a class="headerlink" href="#pynever.nodes.FullyConnectedNode.out_features" title="Link to this definition"></a></dt>
<dd><p>Number of output features of the fully connected layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.FullyConnectedNode.weight">
<span class="sig-name descname"><span class="pre">weight</span></span><a class="headerlink" href="#pynever.nodes.FullyConnectedNode.weight" title="Link to this definition"></a></dt>
<dd><p>Tensor containing the weight parameters of the fully connected layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.FullyConnectedNode.bias">
<span class="sig-name descname"><span class="pre">bias</span></span><a class="headerlink" href="#pynever.nodes.FullyConnectedNode.bias" title="Link to this definition"></a></dt>
<dd><p>Tensor containing the bias parameters of the fully connected layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.FullyConnectedNode.has_bias">
<span class="sig-name descname"><span class="pre">has_bias</span></span><a class="headerlink" href="#pynever.nodes.FullyConnectedNode.has_bias" title="Link to this definition"></a></dt>
<dd><p>Flag True if the fully connected layer has bias, False otherwise (default: True)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.FullyConnectedNode.get_layer_bias_as_two_dimensional">
<span class="sig-name descname"><span class="pre">get_layer_bias_as_two_dimensional</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#FullyConnectedNode.get_layer_bias_as_two_dimensional"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.FullyConnectedNode.get_layer_bias_as_two_dimensional" title="Link to this definition"></a></dt>
<dd><p>This method expands the bias since they are memorized
like one-dimensional vectors in FC nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The new bias with explicit dimensions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.FullyConnectedNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#FullyConnectedNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.FullyConnectedNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">BatchNormNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">running_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">running_var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">momentum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">track_running_stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#BatchNormNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.BatchNormNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a one dimensional Batch Normalization Layer.
N.B. There are some problem for compatibility between pytorch and onnx: pytorch provide 3 different kind
of batchnorm layers which supports [(N, C) or (N, C, L)], (N, C, H, W) and (N, C, D, H, W) dimensional inputs
respectively (BatchNorm1D, BatchNorm2D and BatchNorm3D). The batchnorm operation is always applied to the
C dimension (N is the batch dimension which we do not keep track of). ONNX accepts input in the form of
(N, C, D1, … , Dn) where N is the batch dimension and C is the dimension to which the batchnorm is applied.
It should also be noted that at present the pytorch constructors do not support the setting of weight and
bias explicitly.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.num_features">
<span class="sig-name descname"><span class="pre">num_features</span></span><a class="headerlink" href="#pynever.nodes.BatchNormNode.num_features" title="Link to this definition"></a></dt>
<dd><p>Number of input and output feature of the Batch Normalization Layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.weight">
<span class="sig-name descname"><span class="pre">weight</span></span><a class="headerlink" href="#pynever.nodes.BatchNormNode.weight" title="Link to this definition"></a></dt>
<dd><p>Tensor containing the weight parameters of the Batch Normalization Layer. (default: None)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.bias">
<span class="sig-name descname"><span class="pre">bias</span></span><a class="headerlink" href="#pynever.nodes.BatchNormNode.bias" title="Link to this definition"></a></dt>
<dd><p>Tensor containing the bias parameter of the Batch Normalization Layer. (default: None)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.running_mean">
<span class="sig-name descname"><span class="pre">running_mean</span></span><a class="headerlink" href="#pynever.nodes.BatchNormNode.running_mean" title="Link to this definition"></a></dt>
<dd><p>Tensor containing the running mean parameter of the Batch Normalization Layer. (default: None)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.running_var">
<span class="sig-name descname"><span class="pre">running_var</span></span><a class="headerlink" href="#pynever.nodes.BatchNormNode.running_var" title="Link to this definition"></a></dt>
<dd><p>Tensor containing the running var parameter of the Batch Normalization Layer. (default: None)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.eps">
<span class="sig-name descname"><span class="pre">eps</span></span><a class="headerlink" href="#pynever.nodes.BatchNormNode.eps" title="Link to this definition"></a></dt>
<dd><p>Value added to the denominator for numerical stability (default: 1e-5).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.momentum">
<span class="sig-name descname"><span class="pre">momentum</span></span><a class="headerlink" href="#pynever.nodes.BatchNormNode.momentum" title="Link to this definition"></a></dt>
<dd><p>Value used for the running_mean and running_var computation. Can be set to None
for cumulative moving average (default: 0.1)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.affine">
<span class="sig-name descname"><span class="pre">affine</span></span><a class="headerlink" href="#pynever.nodes.BatchNormNode.affine" title="Link to this definition"></a></dt>
<dd><p>When set to True, the module has learnable affine parameter (default: True).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.track_running_stats">
<span class="sig-name descname"><span class="pre">track_running_stats</span></span><a class="headerlink" href="#pynever.nodes.BatchNormNode.track_running_stats" title="Link to this definition"></a></dt>
<dd><p>When set to True, the module tracks the running mean and variance, when set to false the module
does not track such statistics and always uses batch statistics in both training and eval modes (default: True).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.BatchNormNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#BatchNormNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.BatchNormNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">ConvNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">has_bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ConvNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ConvNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Convolutional layer.
Also in this case the pytorch and onnx representation present incompatibilities. As in Batchnorm pytorch
provide 3 different class for convolution based on the dimensionality of the input considered.
Moreover, the padding is forced to be symmetric.
The dimensionality supported for the input are (N, C, L), (N, C, H, W) and (N, C, D, H, W).
In ONNX the padding can be asymmetric and the dimensionality supported is (N, C, D1, … , Dn) where D1, … Dn
are the dimension on which the convolution is applied</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.in_channels">
<span class="sig-name descname"><span class="pre">in_channels</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.in_channels" title="Link to this definition"></a></dt>
<dd><p>Number of input channels in Conv Layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.out_channels">
<span class="sig-name descname"><span class="pre">out_channels</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.out_channels" title="Link to this definition"></a></dt>
<dd><p>Number of output channels in Conv Layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.kernel_size">
<span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.kernel_size" title="Link to this definition"></a></dt>
<dd><p>The size of the kernel. Should have size equal to the number of dimension n
(we don’t count the channel dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.stride">
<span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.stride" title="Link to this definition"></a></dt>
<dd><p>Stride along each spatial axis. Should have size equal to the number of dimension n
(we don’t count the channel dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.padding">
<span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.padding" title="Link to this definition"></a></dt>
<dd><p>Padding for the beginning and ending along each spatial axis.
Padding format should be as follows [x1_begin, x2_begin…x1_end, x2_end,…], where xi_begin the number of
pixels added at the beginning of axis <cite>i</cite> and xi_end, the number of pixels added at the end of axis <cite>i</cite>.
Should have size equal to two times the number of dimension n (we don’t count the channel dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.dilation">
<span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.dilation" title="Link to this definition"></a></dt>
<dd><p>Dilation value along each spatial axis of the filter</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.groups">
<span class="sig-name descname"><span class="pre">groups</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.groups" title="Link to this definition"></a></dt>
<dd><p>Number of groups input channels and output channels are divided into</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.has_bias">
<span class="sig-name descname"><span class="pre">has_bias</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.has_bias" title="Link to this definition"></a></dt>
<dd><p>Flag True if the convolutional layer has bias, False otherwise (default: False)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.bias">
<span class="sig-name descname"><span class="pre">bias</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.bias" title="Link to this definition"></a></dt>
<dd><p>Tensor containing the bias parameter of the Conv Layer (default: None)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.weight">
<span class="sig-name descname"><span class="pre">weight</span></span><a class="headerlink" href="#pynever.nodes.ConvNode.weight" title="Link to this definition"></a></dt>
<dd><p>Tensor containing the weight parameters of the Conv layer (default: None)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.ConvNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ConvNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ConvNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.AveragePoolNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">AveragePoolNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ceil_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count_include_pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#AveragePoolNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.AveragePoolNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a AveragePool layer.
Also in this case the pytorch and onnx representation present incompatibilities. As in Batchnorm pytorch
provide 3 different class for pooling based on the dimensionality of the input considered.
Moreover, the padding is forced to be symmetric and the parameter divisor_override is present (it is not clear
what is its effect). The dimensionality supported for the input are (N, C, L), (N, C, H, W) and (N, C, D, H, W).
In ONNX the padding can be asymmetric and the dimensionality supported is (N, C, D1, … , Dn) where D1, … Dn
are the dimension on which the pooling is applied</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.AveragePoolNode.kernel_size">
<span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#pynever.nodes.AveragePoolNode.kernel_size" title="Link to this definition"></a></dt>
<dd><p>The size of the kernel. Should have size equal to the number of dimension n
(we don’t count the channel dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.AveragePoolNode.stride">
<span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#pynever.nodes.AveragePoolNode.stride" title="Link to this definition"></a></dt>
<dd><p>Stride along each spatial axis. Should have size equal to the number of dimension n
(we don’t count the channel dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.AveragePoolNode.padding">
<span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#pynever.nodes.AveragePoolNode.padding" title="Link to this definition"></a></dt>
<dd><p>Padding for the beginning and ending along each spatial axis.
Padding format should be as follows [x1_begin, x2_begin…x1_end, x2_end,…], where xi_begin the number of
pixels added at the beginning of axis <cite>i</cite> and xi_end, the number of pixels added at the end of axis <cite>i</cite>.
Should have size equal to two times the number of dimension n (we don’t count the channel dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.AveragePoolNode.ceil_mode">
<span class="sig-name descname"><span class="pre">ceil_mode</span></span><a class="headerlink" href="#pynever.nodes.AveragePoolNode.ceil_mode" title="Link to this definition"></a></dt>
<dd><p>In order to use ceil mode. (default: False)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.AveragePoolNode.count_include_pad">
<span class="sig-name descname"><span class="pre">count_include_pad</span></span><a class="headerlink" href="#pynever.nodes.AveragePoolNode.count_include_pad" title="Link to this definition"></a></dt>
<dd><p>Whether include pad pixels when calculating values for the edges (default: False)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.AveragePoolNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#AveragePoolNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.AveragePoolNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.MaxPoolNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">MaxPoolNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dilation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ceil_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#MaxPoolNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.MaxPoolNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a MaxPool layer.
Also in this case the pytorch and onnx representation present incompatibilities. As in Batchnorm pytorch
provide 3 different class for pooling based on the dimensionality of the input considered.
Moreover, the padding is forced to be symmetric. The dimensionality supported for the input
are (N, C, L), (N, C, H, W) and (N, C, D, H, W).
In ONNX the padding can be asymmetric and the dimensionality supported is (N, C, D1, … , Dn) where D1, … Dn
are the dimension on which the pooling is applied</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.MaxPoolNode.kernel_size">
<span class="sig-name descname"><span class="pre">kernel_size</span></span><a class="headerlink" href="#pynever.nodes.MaxPoolNode.kernel_size" title="Link to this definition"></a></dt>
<dd><p>The size of the kernel. Should have size equal to the number of dimension n
(we don’t count the channel dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.MaxPoolNode.stride">
<span class="sig-name descname"><span class="pre">stride</span></span><a class="headerlink" href="#pynever.nodes.MaxPoolNode.stride" title="Link to this definition"></a></dt>
<dd><p>Stride along each spatial axis. Should have size equal to the number of dimension n
(we don’t count the channel dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.MaxPoolNode.padding">
<span class="sig-name descname"><span class="pre">padding</span></span><a class="headerlink" href="#pynever.nodes.MaxPoolNode.padding" title="Link to this definition"></a></dt>
<dd><p>Padding for the beginning and ending along each spatial axis.
Padding format should be as follows [x1_begin, x2_begin…x1_end, x2_end,…], where xi_begin the number of
pixels added at the beginning of axis <cite>i</cite> and xi_end, the number of pixels added at the end of axis <cite>i</cite>.
Should have size equal to two times the number of dimension n (we don’t count the channel dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.MaxPoolNode.dilation">
<span class="sig-name descname"><span class="pre">dilation</span></span><a class="headerlink" href="#pynever.nodes.MaxPoolNode.dilation" title="Link to this definition"></a></dt>
<dd><p>Dilation value along each spatial axis of the filter</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.MaxPoolNode.ceil_mode">
<span class="sig-name descname"><span class="pre">ceil_mode</span></span><a class="headerlink" href="#pynever.nodes.MaxPoolNode.ceil_mode" title="Link to this definition"></a></dt>
<dd><p>In order to use ceil mode. (default: False)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.MaxPoolNode.return_indices">
<span class="sig-name descname"><span class="pre">return_indices</span></span><a class="headerlink" href="#pynever.nodes.MaxPoolNode.return_indices" title="Link to this definition"></a></dt>
<dd><p>If True it will return the max indices along with the outputs (default: False)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.MaxPoolNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#MaxPoolNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.MaxPoolNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.LRNNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">LRNNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#LRNNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.LRNNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a LocalResponseNormalization Layer.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.LRNNode.size">
<span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#pynever.nodes.LRNNode.size" title="Link to this definition"></a></dt>
<dd><p>Amount of neighbouring channels used for normalization</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.LRNNode.alpha">
<span class="sig-name descname"><span class="pre">alpha</span></span><a class="headerlink" href="#pynever.nodes.LRNNode.alpha" title="Link to this definition"></a></dt>
<dd><p>Multiplicative factor (default: 0.0001)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.LRNNode.beta">
<span class="sig-name descname"><span class="pre">beta</span></span><a class="headerlink" href="#pynever.nodes.LRNNode.beta" title="Link to this definition"></a></dt>
<dd><p>Exponent. (default: 0.75)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.LRNNode.k">
<span class="sig-name descname"><span class="pre">k</span></span><a class="headerlink" href="#pynever.nodes.LRNNode.k" title="Link to this definition"></a></dt>
<dd><p>Additive factor (default: 1.0)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.LRNNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#LRNNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.LRNNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.SoftMaxNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">SoftMaxNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#SoftMaxNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.SoftMaxNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a SoftMax Layer.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.SoftMaxNode.axis">
<span class="sig-name descname"><span class="pre">axis</span></span><a class="headerlink" href="#pynever.nodes.SoftMaxNode.axis" title="Link to this definition"></a></dt>
<dd><p>A dimension along which Softmax will be computed (so every slice along dim will sum to 1)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.SoftMaxNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#SoftMaxNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.SoftMaxNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.UnsqueezeNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">UnsqueezeNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#UnsqueezeNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.UnsqueezeNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of an Unsqueeze Layer.
We follow the ONNX operator convention for attributes and definitions.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.UnsqueezeNode.axes">
<span class="sig-name descname"><span class="pre">axes</span></span><a class="headerlink" href="#pynever.nodes.UnsqueezeNode.axes" title="Link to this definition"></a></dt>
<dd><p>List of indices at which to insert the singleton dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.UnsqueezeNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#UnsqueezeNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.UnsqueezeNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.ReshapeNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">ReshapeNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_zero</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ReshapeNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ReshapeNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Reshape layer.
We follow the ONNX operator convention for attributes and definitions.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ReshapeNode.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#pynever.nodes.ReshapeNode.shape" title="Link to this definition"></a></dt>
<dd><p>tuple which specifies the output shape</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ReshapeNode.allow_zero">
<span class="sig-name descname"><span class="pre">allow_zero</span></span><a class="headerlink" href="#pynever.nodes.ReshapeNode.allow_zero" title="Link to this definition"></a></dt>
<dd><p>By default, when any value in the ‘shape’ input is equal to zero the corresponding dimension value
is copied from the input tensor dynamically. allowzero=1 indicates that if any value in the ‘shape’ input is
set to zero, the zero value is honored, similar to NumPy. (default: False)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.ReshapeNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ReshapeNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ReshapeNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.FlattenNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">FlattenNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#FlattenNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.FlattenNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Flatten layer. We follow the ONNX operator
convention for attributes and definitions.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.FlattenNode.axis">
<span class="sig-name descname"><span class="pre">axis</span></span><a class="headerlink" href="#pynever.nodes.FlattenNode.axis" title="Link to this definition"></a></dt>
<dd><p>Indicate up to which input dimensions (exclusive) should be flattened to the outer dimension of the output.
The value for axis must be in the range [-r, r], where r is the rank of the input tensor. Negative value
means counting dimensions from the back. When axis = 0, the shape of the output tensor is
(1, (d_0 X d_1 … d_n)), where the shape of the input tensor is (d_0, d_1, … d_n).
N.B: it works assuming the initial batch dimension. (default: 0)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.FlattenNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#FlattenNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.FlattenNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.DropoutNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">DropoutNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#DropoutNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.DropoutNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Dropout Layer.
The inplace parameter of pytorch and the seed attribute and training_mode of onnx are not supported.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.DropoutNode.p">
<span class="sig-name descname"><span class="pre">p</span></span><a class="headerlink" href="#pynever.nodes.DropoutNode.p" title="Link to this definition"></a></dt>
<dd><p>Probability of an element to be zeroed (default: 0.5)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.DropoutNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#DropoutNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.DropoutNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.TransposeNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">TransposeNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#TransposeNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.TransposeNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Dropout Layer.
The inplace parameter of pytorch and the seed attribute and training_mode of onnx are not supported.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.TransposeNode.perm">
<span class="sig-name descname"><span class="pre">perm</span></span><a class="headerlink" href="#pynever.nodes.TransposeNode.perm" title="Link to this definition"></a></dt>
<dd><p>Permutation to apply to the input dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.TransposeNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#TransposeNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.TransposeNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.ConcatNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">ConcatNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ConcatNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ConcatNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Concat Layer.
Concatenate two tensors into a single tensor. All input tensors must have the same shape,
except for the dimension size of the axis to concatenate on.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pynever.nodes.ConcatNode.axis">
<span class="sig-name descname"><span class="pre">axis</span></span><a class="headerlink" href="#pynever.nodes.ConcatNode.axis" title="Link to this definition"></a></dt>
<dd><p>Which axis to concat on. A negative value means counting dimensions from the back.
Accepted range is [-r, r-1] where r is the number of dimension of the input (default: -1).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, Optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.ConcatNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#ConcatNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.ConcatNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pynever.nodes.SumNode">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pynever.nodes.</span></span><span class="sig-name descname"><span class="pre">SumNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">identifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#SumNode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.SumNode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pynever.nodes.ConcreteLayerNode" title="pynever.nodes.ConcreteLayerNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConcreteLayerNode</span></code></a></p>
<p>A class used for our internal representation of a Sum Layer.
Element-wise sum of each of the input tensors.
All inputs and outputs must have the same data type.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pynever.nodes.SumNode.get_input_dim">
<span class="sig-name descname"><span class="pre">get_input_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pynever/nodes.html#SumNode.get_input_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pynever.nodes.SumNode.get_input_dim" title="Link to this definition"></a></dt>
<dd><p>Should be implemented in children depending on whether they have one or more input dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The list of input dimensions if the layer has more than one input, otherwise the first element.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple] | tuple</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="0_Networks.html" class="btn btn-neutral float-left" title="Networks" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="2_Training.html" class="btn btn-neutral float-right" title="Training" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, NeverTools.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>